<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Affine (pure JS)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0f14; color:#d9e2ef; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    /* Canvas-прев’ю інколи дає 0-height для 100%, тому фіксуємо viewport */
    body { height: 100vh; }
    #wrap { display:flex; height:100vh; width:100vw; }

    #ui {
      width: 360px; padding: 14px; box-sizing:border-box; border-right: 1px solid #1d2633;
      background: #0e141d;
      overflow:auto;
    }
    #ui h2 { margin: 0 0 10px; font-size: 16px; }
    .group { margin: 10px 0 14px; padding: 10px; border: 1px solid #1d2633; border-radius: 10px; background:#0b111a; }
    .row { display:grid; grid-template-columns: 68px 1fr 70px; gap: 10px; align-items:center; margin: 6px 0; }
    .row label { opacity: .9; }
    input[type="range"] { width:100%; }
    input[type="number"] { width: 70px; padding: 4px 6px; background:#0e141d; border:1px solid #223047; color:#d9e2ef; border-radius: 8px; }
    button {
      width:100%; margin-top: 8px; padding: 10px 12px; border-radius: 10px; border:1px solid #223047;
      background:#101a28; color:#d9e2ef; cursor:pointer;
    }
    button:hover { background:#122036; }
    .hint { font-size: 12px; opacity: .75; margin-top: 10px; }

    #stage { position: relative; flex:1; min-width: 0; }
    canvas { display:block; width:100%; height:100%; }

    #status {
      position:absolute; top: 12px; right: 12px;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(14,20,29,.75);
      border: 1px solid #223047;
      font-size: 12px;
      max-width: 45vw;
      white-space: pre-wrap;
    }
    #status b { font-weight: 700; }

    pre.matrix {
      margin: 10px 0 0;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #223047;
      background: #0e141d;
      color: #d9e2ef;
      font: 12px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow: auto;
      max-height: 220px;
      white-space: pre;
    }
    button.miniBtn {
      width: auto;
      margin: 0;
      padding: 6px 10px;
      border-radius: 10px;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <h2>3D афінні перетворення</h2>

    <div class="group">
      <div><b>Translate</b></div>
      <div class="row"><label>Tx</label><input id="tx" type="range" min="-5" max="5" step="0.01" value="0"><input id="tx_n" type="number" step="0.01" value="0"></div>
      <div class="row"><label>Ty</label><input id="ty" type="range" min="-5" max="5" step="0.01" value="0"><input id="ty_n" type="number" step="0.01" value="0"></div>
      <div class="row"><label>Tz</label><input id="tz" type="range" min="-10" max="2" step="0.01" value="-4"><input id="tz_n" type="number" step="0.01" value="-4"></div>
    </div>

    <div class="group">
      <div><b>Rotate (deg)</b></div>
      <div class="row"><label>Rx</label><input id="rx" type="range" min="-180" max="180" step="1" value="20"><input id="rx_n" type="number" step="1" value="20"></div>
      <div class="row"><label>Ry</label><input id="ry" type="range" min="-180" max="180" step="1" value="35"><input id="ry_n" type="number" step="1" value="35"></div>
      <div class="row"><label>Rz</label><input id="rz" type="range" min="-180" max="180" step="1" value="0"><input id="rz_n" type="number" step="1" value="0"></div>
    </div>

    <div class="group">
      <div><b>Scale</b></div>
      <div class="row"><label>Sx</label><input id="sx" type="range" min="0.1" max="3" step="0.01" value="1"><input id="sx_n" type="number" step="0.01" value="1"></div>
      <div class="row"><label>Sy</label><input id="sy" type="range" min="0.1" max="3" step="0.01" value="1"><input id="sy_n" type="number" step="0.01" value="1"></div>
      <div class="row"><label>Sz</label><input id="sz" type="range" min="0.1" max="3" step="0.01" value="1"><input id="sz_n" type="number" step="0.01" value="1"></div>
    </div>

    <div class="group">
      <div><b>Shear</b> (зсув осей)</div>
      <div class="row"><label>XY</label><input id="shxy" type="range" min="-1" max="1" step="0.01" value="0"><input id="shxy_n" type="number" step="0.01" value="0"></div>
      <div class="row"><label>XZ</label><input id="shxz" type="range" min="-1" max="1" step="0.01" value="0"><input id="shxz_n" type="number" step="0.01" value="0"></div>
      <div class="row"><label>YZ</label><input id="shyz" type="range" min="-1" max="1" step="0.01" value="0"><input id="shyz_n" type="number" step="0.01" value="0"></div>
    </div>

    <div class="group">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <div><b>Matrix</b> (row×col)</div>
        <div style="display:flex;gap:8px;">
          <button id="copyM" class="miniBtn" type="button">Copy M</button>
          <button id="copyMVP" class="miniBtn" type="button">Copy MVP</button>
        </div>
      </div>
      <pre id="matM" class="matrix">M = …</pre>
      <pre id="matMVP" class="matrix">MVP = …</pre>
      <div class="hint">Внутрішнє представлення: column-major (WebGL). Відображення: 4×4 рядками.</div>
    </div>

    <button id="reset">Reset</button>
    <div class="hint">
      Пайплайн: <code>M = T · Rz · Ry · Rx · Shear · S</code>, далі <code>MVP = P · V · M</code>.<br/>
      Якщо WebGL2 недоступний у Canvas-прев’ю — вмикається fallback на Canvas2D (wireframe).
    </div>
  </div>

  <div id="stage">
    <canvas id="c"></canvas>
    <div id="status"><b>Init…</b></div>
  </div>
</div>

<script>
(() => {
  // ---------------- Status ----------------
  const statusEl = document.getElementById('status');
  function setStatus(title, details){
    // уникаємо шаблонних рядків з випадковими переведеннями рядків
    const t = String(title ?? '');
    const d = details ? String(details) : '';
    statusEl.innerHTML = '';
    const b = document.createElement('b');
    b.textContent = t;
    statusEl.appendChild(b);
    if (d) {
      statusEl.appendChild(document.createTextNode('\n' + d));
    }
  }

  // ---------------- UI wiring ----------------
  const ids = ['tx','ty','tz','rx','ry','rz','sx','sy','sz','shxy','shxz','shyz'];
  const state = Object.fromEntries(ids.map(k => [k, 0]));

  function bindPair(id){
    const r = document.getElementById(id);
    const n = document.getElementById(id + '_n');
    const sync = (v) => { r.value = v; n.value = v; state[id] = parseFloat(v); };
    r.addEventListener('input', e => sync(e.target.value));
    n.addEventListener('input', e => sync(e.target.value));
    sync(r.value);
  }
  ids.forEach(bindPair);

  document.getElementById('reset').addEventListener('click', () => {
    const preset = { tx:0,ty:0,tz:-4, rx:20,ry:35,rz:0, sx:1,sy:1,sz:1, shxy:0,shxz:0,shyz:0 };
    for (const k of ids){
      const v = preset[k];
      document.getElementById(k).value = v;
      document.getElementById(k + '_n').value = v;
      state[k] = v;
    }
  });

  // ---------------- Matrix UI ----------------
  const matMEl = document.getElementById('matM');
  const matMVPEl = document.getElementById('matMVP');
  const copyMBtn = document.getElementById('copyM');
  const copyMVPBtn = document.getElementById('copyMVP');

  function fmtMat4(m){
    // m is column-major. Print as 4 rows × 4 cols.
    const cell = (v) => {
      const vv = Math.abs(v) < 1e-8 ? 0 : v;
      return vv.toFixed(4).padStart(9, ' ');
    };
    const rows = [];
    for (let r = 0; r < 4; r++) {
      const row = [];
      for (let c = 0; c < 4; c++) row.push(cell(m[c*4 + r]));
      rows.push(row.join(' '));
    }
    return rows.join('\n');
  }

  function fmtMat4CSV(m){
    // Row-major CSV
    const rows = [];
    for (let r = 0; r < 4; r++) {
      const row = [];
      for (let c = 0; c < 4; c++) row.push(String(m[c*4 + r]));
      rows.push(row.join(','));
    }
    return rows.join('\n');
  }

  let lastSig = '';
  function updateMatricesUI(M, MVP){
    const sig = ids.map(k => state[k]).join('|');
    if (sig === lastSig) return;
    lastSig = sig;

    if (matMEl) matMEl.textContent = 'M =\n' + fmtMat4(M);
    if (matMVPEl) matMVPEl.textContent = 'MVP =\n' + fmtMat4(MVP);

    if (copyMBtn) copyMBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(fmtMat4CSV(M));
        setStatus('Copied', 'M у буфері обміну (CSV, row-major)');
      } catch {
        setStatus('Copy failed', 'Clipboard API недоступний/заблокований у цьому контексті');
      }
    };
    if (copyMVPBtn) copyMVPBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(fmtMat4CSV(MVP));
        setStatus('Copied', 'MVP у буфері обміну (CSV, row-major)');
      } catch {
        setStatus('Copy failed', 'Clipboard API недоступний/заблокований у цьому контексті');
      }
    };
  }

  // ---------------- Math: mat4 ----------------
  const Mat4 = {
    I(){ return new Float32Array([1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]); },
    mul(a,b){ // a*b (column-major)
      const o = new Float32Array(16);
      for (let c=0;c<4;c++){
        for (let r=0;r<4;r++){
          o[c*4+r] =
            a[0*4+r]*b[c*4+0] +
            a[1*4+r]*b[c*4+1] +
            a[2*4+r]*b[c*4+2] +
            a[3*4+r]*b[c*4+3];
        }
      }
      return o;
    },
    translate(tx,ty,tz){
      const m = Mat4.I();
      m[12]=tx; m[13]=ty; m[14]=tz;
      return m;
    },
    scale(sx,sy,sz){
      const m = Mat4.I();
      m[0]=sx; m[5]=sy; m[10]=sz;
      return m;
    },
    rotX(rad){
      const c=Math.cos(rad), s=Math.sin(rad);
      return new Float32Array([1,0,0,0,  0,c,s,0,  0,-s,c,0,  0,0,0,1]);
    },
    rotY(rad){
      const c=Math.cos(rad), s=Math.sin(rad);
      return new Float32Array([c,0,-s,0,  0,1,0,0,  s,0,c,0,  0,0,0,1]);
    },
    rotZ(rad){
      const c=Math.cos(rad), s=Math.sin(rad);
      return new Float32Array([c,s,0,0,  -s,c,0,0,  0,0,1,0,  0,0,0,1]);
    },
    shearXY_XZ_YZ(shxy, shxz, shyz){
      // x' = x + shxy*y + shxz*z
      // y' = y + shyz*z
      // z' = z
      const m = Mat4.I();
      m[4] = shxy;
      m[8] = shxz;
      m[9] = shyz;
      return m;
    },
    perspective(fovyRad, aspect, near, far){
      const f = 1 / Math.tan(fovyRad/2);
      const nf = 1/(near - far);
      const m = new Float32Array(16);
      m[0]=f/aspect; m[5]=f; m[10]=(far+near)*nf; m[11]=-1;
      m[14]=2*far*near*nf;
      return m;
    },
    lookAt(eye, target, up){
      // Standard right-handed lookAt (column-major, column vectors)
      const ex = eye[0], ey = eye[1], ez = eye[2];
      const tx = target[0], ty = target[1], tz = target[2];

      // f = normalize(target - eye)
      let fx = tx - ex, fy = ty - ey, fz = tz - ez;
      let fl = Math.hypot(fx, fy, fz); if (fl === 0) fl = 1;
      fx /= fl; fy /= fl; fz /= fl;

      // s = normalize(cross(f, up))
      let sx = fy*up[2] - fz*up[1];
      let sy = fz*up[0] - fx*up[2];
      let sz = fx*up[1] - fy*up[0];
      let sl = Math.hypot(sx, sy, sz); if (sl === 0) sl = 1;
      sx /= sl; sy /= sl; sz /= sl;

      // u = cross(s, f)
      const ux = sy*fz - sz*fy;
      const uy = sz*fx - sx*fz;
      const uz = sx*fy - sy*fx;

      const m = new Float32Array(16);
      m[0] = sx;  m[4] = ux;  m[8]  = -fx; m[12] = 0;
      m[1] = sy;  m[5] = uy;  m[9]  = -fy; m[13] = 0;
      m[2] = sz;  m[6] = uz;  m[10] = -fz; m[14] = 0;
      m[3] = 0;   m[7] = 0;   m[11] = 0;   m[15] = 1;

      m[12] = -(sx*ex + sy*ey + sz*ez);
      m[13] = -(ux*ex + uy*ey + uz*ez);
      m[14] =  (fx*ex + fy*ey + fz*ez);
      return m;
    },
    transformVec4(m, x,y,z,w){
      return [
        m[0]*x + m[4]*y + m[8]*z  + m[12]*w,
        m[1]*x + m[5]*y + m[9]*z  + m[13]*w,
        m[2]*x + m[6]*y + m[10]*z + m[14]*w,
        m[3]*x + m[7]*y + m[11]*z + m[15]*w,
      ];
    },
    normalMat3FromMat4(m4){
      // inverse-transpose of upper-left 3x3
      const a = m4[0], b = m4[4], c = m4[8];
      const d = m4[1], e = m4[5], f = m4[9];
      const g = m4[2], h = m4[6], i = m4[10];

      const det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
      if (Math.abs(det) < 1e-8) return new Float32Array([1,0,0, 0,1,0, 0,0,1]);
      const invDet = 1.0 / det;

      // inverse (row-major)
      const inv00 =  (e*i - f*h) * invDet;
      const inv01 =  (c*h - b*i) * invDet;
      const inv02 =  (b*f - c*e) * invDet;

      const inv10 =  (f*g - d*i) * invDet;
      const inv11 =  (a*i - c*g) * invDet;
      const inv12 =  (c*d - a*f) * invDet;

      const inv20 =  (d*h - e*g) * invDet;
      const inv21 =  (b*g - a*h) * invDet;
      const inv22 =  (a*e - b*d) * invDet;

      // transpose(inverse) as column-major mat3
      return new Float32Array([
        inv00, inv01, inv02,
        inv10, inv11, inv12,
        inv20, inv21, inv22,
      ]);
    }
  };

  function deg2rad(d){ return d * Math.PI / 180; }

  // ---------------- Self-tests (console) ----------------
  function runSelfTests(){
    const I = Mat4.I();
    const A = Mat4.translate(1,2,3);
    const IA = Mat4.mul(I, A);
    console.assert(Math.abs(IA[12] - 1) < 1e-9 && Math.abs(IA[13] - 2) < 1e-9 && Math.abs(IA[14] - 3) < 1e-9, 'Mat4.mul identity failed');

    const S = Mat4.scale(2,3,4);
    const N = Mat4.normalMat3FromMat4(S);
    console.assert(N.length === 9, 'normal matrix size');

    const v = Mat4.transformVec4(A, 0,0,0,1);
    console.assert(Math.abs(v[0]-1)<1e-9 && Math.abs(v[1]-2)<1e-9 && Math.abs(v[2]-3)<1e-9, 'transformVec4 translate failed');
  }
  runSelfTests();

  // ---------------- Scene matrices ----------------
  function buildMatrices(canvas){
    const aspect = canvas.width / canvas.height;
    const P = Mat4.perspective(deg2rad(55), aspect, 0.1, 100.0);
    const V = Mat4.lookAt([0, 0.8, 5.5], [0,0,0], [0,1,0]);

    const T  = Mat4.translate(state.tx, state.ty, state.tz);
    const Rx = Mat4.rotX(deg2rad(state.rx));
    const Ry = Mat4.rotY(deg2rad(state.ry));
    const Rz = Mat4.rotZ(deg2rad(state.rz));
    const S  = Mat4.scale(state.sx, state.sy, state.sz);
    const Sh = Mat4.shearXY_XZ_YZ(state.shxy, state.shxz, state.shyz);

    // M = T · Rz · Ry · Rx · Sh · S
    const M = Mat4.mul(T, Mat4.mul(Rz, Mat4.mul(Ry, Mat4.mul(Rx, Mat4.mul(Sh, S)))));
    const MVP = Mat4.mul(P, Mat4.mul(V, M));
    const MVPaxes = Mat4.mul(P, V);

    return { P, V, M, MVP, MVPaxes };
  }

  // ---------------- Resize ----------------
  const canvas = document.getElementById('c');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.max(2, Math.floor(canvas.clientWidth * dpr));
    const h = Math.max(2, Math.floor(canvas.clientHeight * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
  }
  window.addEventListener('resize', resize);

  // ---------------- WebGL2 init ----------------
  function tryInitWebGL2(){
    const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });
    if (!gl) return null;

    const vs = `#version 300 es\n\
in vec3 aPos;\n\
in vec3 aCol;\n\
in vec3 aNrm;\n\
\n\
uniform mat4 uMVP;\n\
uniform mat4 uModelView;\n\
uniform mat3 uNormalMat;\n\
\n\
out vec3 vCol;\n\
out vec3 vNrm;\n\
out vec3 vPosView;\n\
\n\
void main(){\n\
  vCol = aCol;\n\
  vPosView = (uModelView * vec4(aPos, 1.0)).xyz;\n\
  vNrm = normalize(uNormalMat * aNrm);\n\
  gl_Position = uMVP * vec4(aPos, 1.0);\n\
}`;

    const fs = `#version 300 es\n\
precision highp float;\n\
\n\
in vec3 vCol;\n\
in vec3 vNrm;\n\
in vec3 vPosView;\n\
\n\
uniform vec3 uLightDirView;\n\
uniform float uAmbient;\n\
uniform float uDiffuse;\n\
uniform float uSpecular;\n\
uniform float uShininess;\n\
uniform float uUnlit;\n\
\n\
out vec4 o;\n\
\n\
void main(){\n\
  if (uUnlit > 0.5) {\n\
    o = vec4(vCol, 1.0);\n\
    return;\n\
  }\n\
\n\
  vec3 N = normalize(vNrm);\n\
  vec3 L = normalize(uLightDirView);\n\
  vec3 V = normalize(-vPosView);\n\
\n\
  float diff = max(dot(N, L), 0.0);\n\
  vec3 H = normalize(L + V);\n\
  float spec = pow(max(dot(N, H), 0.0), uShininess);\n\
\n\
  vec3 color = vCol * (uAmbient + uDiffuse * diff) + vec3(uSpecular * spec);\n\
  o = vec4(color, 1.0);\n\
}`;

    function compile(type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        const msg = gl.getShaderInfoLog(s) || 'shader compile error';
        gl.deleteShader(s);
        throw new Error(msg);
      }
      return s;
    }

    function makeProgram(vsSrc, fsSrc){
      const p = gl.createProgram();
      gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
      gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)){
        const msg = gl.getProgramInfoLog(p) || 'program link error';
        gl.deleteProgram(p);
        throw new Error(msg);
      }
      return p;
    }

    const prog = makeProgram(vs, fs);
    gl.useProgram(prog);

    const locMVP = gl.getUniformLocation(prog, 'uMVP');
    const locMV  = gl.getUniformLocation(prog, 'uModelView');
    const locNrm = gl.getUniformLocation(prog, 'uNormalMat');

    const locLightDir = gl.getUniformLocation(prog, 'uLightDirView');
    const locAmbient  = gl.getUniformLocation(prog, 'uAmbient');
    const locDiffuse  = gl.getUniformLocation(prog, 'uDiffuse');
    const locSpecular = gl.getUniformLocation(prog, 'uSpecular');
    const locShine    = gl.getUniformLocation(prog, 'uShininess');
    const locUnlit    = gl.getUniformLocation(prog, 'uUnlit');

    // Lighting defaults (під читабельні деформації)
    gl.uniform3f(locLightDir, 0.35, 0.75, 0.55);
    gl.uniform1f(locAmbient, 0.22);
    gl.uniform1f(locDiffuse, 0.95);
    gl.uniform1f(locSpecular, 0.25);
    gl.uniform1f(locShine, 48.0);
    gl.uniform1f(locUnlit, 0.0);

    // Geometry (interleaved): pos3 + col3 + nrm3
    function pushTri(out, p0,p1,p2, col, nrm){
      out.push(
        p0[0],p0[1],p0[2],  col[0],col[1],col[2],  nrm[0],nrm[1],nrm[2],
        p1[0],p1[1],p1[2],  col[0],col[1],col[2],  nrm[0],nrm[1],nrm[2],
        p2[0],p2[1],p2[2],  col[0],col[1],col[2],  nrm[0],nrm[1],nrm[2],
      );
    }

    function buildCubeLit(){
      const out = [];
      const col = [0.80, 0.90, 1.00];
      const p = {
        nnn: [-0.5,-0.5,-0.5], pnn: [ 0.5,-0.5,-0.5], ppn: [ 0.5, 0.5,-0.5], npn: [-0.5, 0.5,-0.5],
        nnp: [-0.5,-0.5, 0.5], pnp: [ 0.5,-0.5, 0.5], ppp: [ 0.5, 0.5, 0.5], npp: [-0.5, 0.5, 0.5],
      };

      // +Z
      pushTri(out, p.nnp, p.pnp, p.ppp, col, [0,0,1]);
      pushTri(out, p.nnp, p.ppp, p.npp, col, [0,0,1]);
      // -Z
      pushTri(out, p.nnn, p.ppn, p.pnn, col, [0,0,-1]);
      pushTri(out, p.nnn, p.npn, p.ppn, col, [0,0,-1]);
      // -X
      pushTri(out, p.nnn, p.npp, p.npn, col, [-1,0,0]);
      pushTri(out, p.nnn, p.nnp, p.npp, col, [-1,0,0]);
      // +X
      pushTri(out, p.pnn, p.ppn, p.ppp, col, [1,0,0]);
      pushTri(out, p.pnn, p.ppp, p.pnp, col, [1,0,0]);
      // +Y
      pushTri(out, p.npn, p.npp, p.ppp, col, [0,1,0]);
      pushTri(out, p.npn, p.ppp, p.ppn, col, [0,1,0]);
      // -Y
      pushTri(out, p.nnn, p.pnp, p.nnp, col, [0,-1,0]);
      pushTri(out, p.nnn, p.pnn, p.pnp, col, [0,-1,0]);

      return out;
    }

    const cube = buildCubeLit();

    const axes = [
      0,0,0,   1,0.25,0.25,  0,0,1,
      2,0,0,   1,0.25,0.25,  0,0,1,
      0,0,0,   0.25,1,0.25,  0,0,1,
      0,2,0,   0.25,1,0.25,  0,0,1,
      0,0,0,   0.25,0.65,1,  0,0,1,
      0,0,2,   0.25,0.65,1,  0,0,1,
    ];

    function makeVAO(interleaved){
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(interleaved), gl.STATIC_DRAW);

      const stride = 9 * 4;
      const locPos = gl.getAttribLocation(prog, 'aPos');
      const locCol = gl.getAttribLocation(prog, 'aCol');
      const locNrmAttr = gl.getAttribLocation(prog, 'aNrm');

      gl.enableVertexAttribArray(locPos);
      gl.vertexAttribPointer(locPos, 3, gl.FLOAT, false, stride, 0);

      gl.enableVertexAttribArray(locCol);
      gl.vertexAttribPointer(locCol, 3, gl.FLOAT, false, stride, 3*4);

      gl.enableVertexAttribArray(locNrmAttr);
      gl.vertexAttribPointer(locNrmAttr, 3, gl.FLOAT, false, stride, 6*4);

      gl.bindVertexArray(null);
      return { vao, count: interleaved.length / 9 };
    }

    const cubeVAO = makeVAO(cube);
    const axesVAO = makeVAO(axes);

    gl.enable(gl.DEPTH_TEST);

    return { gl, prog, locMVP, locMV, locNrm, locUnlit, cubeVAO, axesVAO };
  }

  function runWebGL2(ctx){
    const { gl, locMVP, locMV, locNrm, locUnlit, cubeVAO, axesVAO } = ctx;
    setStatus('Render: WebGL2', 'OK • Lighting: directional + ambient + specular');

    function frame(){
      resize();
      gl.viewport(0,0,canvas.width,canvas.height);
      gl.clearColor(0.04, 0.06, 0.08, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const { MVP, MVPaxes, V, M } = buildMatrices(canvas);
      updateMatricesUI(M, MVP);

      const MV = Mat4.mul(V, M);
      const normalMat = Mat4.normalMat3FromMat4(MV);

      // Cube (lit)
      gl.uniform1f(locUnlit, 0.0);
      gl.uniformMatrix4fv(locMVP, false, MVP);
      gl.uniformMatrix4fv(locMV, false, MV);
      gl.uniformMatrix3fv(locNrm, false, normalMat);
      gl.bindVertexArray(cubeVAO.vao);
      gl.drawArrays(gl.TRIANGLES, 0, cubeVAO.count);

      // Axes (unlit)
      gl.uniform1f(locUnlit, 1.0);
      gl.uniformMatrix4fv(locMVP, false, MVPaxes);
      gl.uniformMatrix4fv(locMV, false, V);
      gl.uniformMatrix3fv(locNrm, false, Mat4.normalMat3FromMat4(V));
      gl.bindVertexArray(axesVAO.vao);
      gl.drawArrays(gl.LINES, 0, axesVAO.count);

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  }

  function runCanvas2D(){
    const ctx = canvas.getContext('2d', { alpha: false });
    setStatus('Render: Canvas2D fallback', 'WebGL2 недоступний у цьому середовищі');

    const cubeVerts = [
      [-0.5,-0.5,-0.5], [0.5,-0.5,-0.5], [0.5,0.5,-0.5], [-0.5,0.5,-0.5],
      [-0.5,-0.5, 0.5], [0.5,-0.5, 0.5], [0.5,0.5, 0.5], [-0.5,0.5, 0.5],
    ];
    const edges = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7],
    ];

    const axes = [
      { a:[0,0,0], b:[2,0,0], c:'#ff4d4d' },
      { a:[0,0,0], b:[0,2,0], c:'#4dff4d' },
      { a:[0,0,0], b:[0,0,2], c:'#4da6ff' },
    ];

    function project(mvp, p){
      const [x,y,z] = p;
      const [cx,cy,cz,cw] = Mat4.transformVec4(mvp, x,y,z,1);
      if (cw === 0) return null;
      const ndcX = cx / cw;
      const ndcY = cy / cw;
      const sx = (ndcX * 0.5 + 0.5) * canvas.width;
      const sy = (1 - (ndcY * 0.5 + 0.5)) * canvas.height;
      return { x:sx, y:sy };
    }

    function frame(){
      resize();
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const { MVP, MVPaxes, M } = buildMatrices(canvas);
      updateMatricesUI(M, MVP);

      // axes
      ctx.lineWidth = 2;
      for (const ax of axes){
        const p1 = project(MVPaxes, ax.a);
        const p2 = project(MVPaxes, ax.b);
        if (!p1 || !p2) continue;
        ctx.strokeStyle = ax.c;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // cube wireframe
      const pts = cubeVerts.map(v => project(MVP, v));
      ctx.strokeStyle = 'rgba(217,226,239,0.9)';
      ctx.lineWidth = 2;
      for (const [i,j] of edges){
        const a = pts[i], b = pts[j];
        if (!a || !b) continue;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  }

  // ---------------- Boot ----------------
  try {
    resize();
    const webgl = tryInitWebGL2();
    if (webgl) runWebGL2(webgl);
    else runCanvas2D();
  } catch (e) {
    setStatus('Runtime error', String(e && e.message ? e.message : e));
    try { runCanvas2D(); } catch (_) {}
  }
})();
</script>
</body>
</html>
